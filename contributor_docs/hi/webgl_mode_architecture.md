# p5.js WebGL मोड आर्किटेक्चर

यह दस्तावेज़ उन योगदानकर्ताओं और पुस्तकालय निर्माताओं के लिए है जो WebGL कोडबेस का विस्तार करना चाहते हैं। यदि आप अपने स्केच में वेबजीएल मोड का उपयोग करने में सहायता ढूंढ रहे हैं, तो इसके बजाय वेबजीएल ट्यूटोरियल [पी5.जेएस लर्न पेज पर](https://p5js.org/learn/) पढ़ने पर विचार करें।


## वेबजीएल मोड क्या है?

ऐसे दो रेंडरर हैं जिन्हें p5.js 2D और WebGL मोड में चला सकते हैं। p5.js में WebGL मोड उपयोगकर्ता को उच्च-रेंडरिंग के लिए वेब ब्राउज़र में निर्मित [WebGL API](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) का उपयोग करने की अनुमति देता है। प्रदर्शन 2डी और 3डी ग्राफिक्स। 2डी मोड और वेबजीएल मोड के बीच मुख्य अंतर यह है कि बाद वाला कंप्यूटर के जीपीयू तक अधिक सीधी पहुंच प्रदान करता है, जिससे यह 3डी में आकृतियों को प्रदर्शनपूर्वक प्रस्तुत करने या अन्य ग्राफिक्स और छवि प्रसंस्करण कार्यों को करने की अनुमति देता है।

हम [एक GitHub प्रोजेक्ट](https://github.com/orgs/processing/projects/20) में WebGL मुद्दों की प्रगति पर नज़र रखते हैं। 

## वेबजीएल मोड के लक्ष्य

किसी नई सुविधा का मूल्यांकन करते समय, हम इस बात पर विचार करते हैं कि क्या यह p5.js और WebGL मोड के लक्ष्यों के अनुरूप है:

1. **सुविधाएँ शुरुआती के अनुकूल होनी चाहिए:** इसे WebGL और इसके द्वारा प्रदान की जाने वाली सुविधाओं का **शुरुआती-अनुकूल परिचय प्रदान करना चाहिए। इसका मतलब है कि हमें 3डी आकृतियों, कैमरों, प्रकाश व्यवस्था और शेडर्स के लिए सरल एपीआई की पेशकश करनी चाहिए। हम अभी भी उन्नत सुविधाओं का समर्थन कर सकते हैं, लेकिन केवल तभी जब वे मुख्य सुविधाओं की सरलता में हस्तक्षेप न करें।
2. **2डी मोड के साथ फीचर समानता में सुधार:**यह 2डी मोड से घर्षण रहित संक्रमण होना चाहिए,** जिससे 3डी और वेबजीएल उपयोगकर्ताओं के लिए अधिक आसानी से "क्लिक" कर सके। इसका मतलब है कि हम ऐसी सुविधाएं बनाने का प्रयास करते हैं जो 2डी मोड और वेबजीएल मोड में भी काम करती हैं। चूँकि WebGL में 3D और शेडर सुविधाएँ भी हैं, इसका मतलब है कि WebGL मोड का लक्ष्य 2D मोड की सुविधाओं का एक सुपरसेट होना है।
3. **सरलता और विस्तारशीलता सर्वोपरि हैं:** इसमें **एक छोटा कोर होना चाहिए और पुस्तकालयों के लिए विस्तार योग्य होना चाहिए।** WebGL मोड को छोटा रखने से मुख्य सुविधाओं को अनुकूलित करना और बग सतह क्षेत्र को कम करना आसान हो जाता है। एक्सटेंशन पुस्तकालयों के माध्यम से अधिक उन्नत सुविधाओं को शामिल करने का अवसर प्रदान करता है।
4. **p5.js के प्रदर्शन में सुधार करें:** इसे **पिछले लक्ष्यों में हस्तक्षेप किए बिना यथासंभव तेज़ चलना चाहिए।** अच्छा प्रदर्शन विभिन्न प्रकार के दर्शकों और उपकरणों के लिए स्केच को सुलभ रखता है। नए एपीआई डिज़ाइन करते समय, हम यह सुनिश्चित करने का प्रयास करते हैं कि डिज़ाइन का कार्यान्वयन प्रभावी हो। हालाँकि, हम 2डी मोड के साथ सरलता और समानता को प्राथमिकता देते हैं।


## 2डी मोड के साथ डिज़ाइन में अंतर

ब्राउज़र के 2डी और वेबजीएल कैनवास संदर्भ एपीआई अमूर्तता के बहुत अलग स्तर प्रदान करते हैं, जिसमें वेबजीएल आम तौर पर निचले स्तर का होता है और 2डी उच्च स्तर का होता है। यह p5.js के WebGL और 2D मोड के बीच कुछ मूलभूत डिज़ाइन अंतरों को प्रेरित करता है।

- **वेबजीएल मोड अधिक गहराई से नेस्टेड डेटा संरचनाएं बनाता है।** 2डी मोड आम तौर पर ब्राउज़र को कमांड भेजता है, जिससे अपेक्षाकृत उथले कॉल स्टैक होते हैं। इसके विपरीत, WebGL मोड आकृतियों को त्रिकोणों में तोड़ने, उन्हें प्रस्तुत करने और अक्सर भविष्य में पुन: उपयोग के लिए उन्हें कैशिंग करने के लिए जिम्मेदार है। अधिक जटिल रेंडरिंग तर्क के कारण कार्यान्वयन को पठनीय और रखरखाव योग्य बनाए रखने के लिए कोड को `p5.Texture`, `p5.RenderBuffer`, और `p5.DataArray` जैसे कई वर्गों में विभाजित करने की आवश्यकता होती है।
- **वेबजीएल मोड अधिक अनुकूलन प्रदान करता है।** उदाहरण के लिए, जबकि 2डी मोड यह नियंत्रित नहीं करता है कि वक्र कैसे प्रस्तुत किए जाते हैं, वेबजीएल उन्हें त्रिकोण में परिवर्तित करने के लिए जिम्मेदार है। हालांकि यह एक समझदार डिफ़ॉल्ट चुनता है, `कर्वडिटेल()` एपीआई उपयोगकर्ताओं को यह नियंत्रित करने देता है कि कितने लाइन सेगमेंट का उपयोग करना है, क्योंकि हम प्रत्येक उपयोग के मामले के लिए गुणवत्ता और प्रदर्शन के सर्वोत्तम संतुलन की भविष्यवाणी नहीं कर सकते हैं।
- **वेबजीएल मोड को उच्च और निम्न-स्तरीय एपीआई को संतुलित करना होगा।** चूंकि ब्राउज़र वेबजीएल एपीआई के साथ बेहतर नियंत्रण उपलब्ध है, इसलिए पी5.जेएस का वेबजीएल मोड उपयोगकर्ताओं को कुछ हद तक नियंत्रण प्रदान करने में सक्षम है जहां 2डी मोड नहीं कर सकता है। फिर हमें उपयोगकर्ताओं के लिए अमूर्तता का सही स्तर चुनने के कार्य का सामना करना पड़ता है। बहुत अधिक है, और वे ब्राउज़र द्वारा प्रदान की जाने वाली कुछ चीज़ों का लाभ उठाने में असमर्थ हैं; बहुत कम, और हम जटिलता और प्रदर्शन के प्रबंधन का बहुत सारा काम उपयोगकर्ता पर डाल देते हैं।


## आकृतियाँ बनाना

### आकृतियाँ बनाना: भरण, स्ट्रोक, और 3डी ज्यामिति

2D और WebGL दोनों में p5.js द्वारा खींची गई हर चीज़ में भरण और स्ट्रोक शामिल हैं। कभी-कभी, हम केवल एक या दूसरे को ही बनाते हैं, लेकिन प्रत्येक आकृति को किसी भी घटक को खींचने के लिए तैयार होना चाहिए।

वेबजीएल में सभी आकृतियाँ त्रिभुजों से बनी हैं। जब कोई उपयोगकर्ता `सर्कल()`, `beginShape(),` या `वर्टेक्स()` जैसे फ़ंक्शन को कॉल करता है, तो रेंडरर को [आकार को बिंदुओं की श्रृंखला में तोड़ना होगा](https://github.com/processing/p5.js/blob/main/src/webgl/3d_primitives.js). बिंदु रेखाओं में जुड़े हुए हैं, और रेखाएँ त्रिभुजों में। उदाहरण के लिए, `सर्कल()` यह पता लगाने के लिए त्रिकोणमिति का उपयोग करता है कि सर्कल के साथ बिंदु कहां रखे जाएं। `curveVertex()` और `bezierVertex()` किसी भी बेज़ियर कर्व को बिंदुओं में बदलने के लिए लुक-अप टेबल बनाते हैं।


#### Fills

भराव बनाने के लिए, किसी आकृति की रूपरेखा को त्रिकोणों से भरना होगा। कुछ ड्राइंग फ़ंक्शन जैसे `beginShape(TRIANGLE_STRIP)` पहले से ही भरण के लिए त्रिकोण प्रदान करते हैं। यदि बनाई जा रही आकृति पहले से ही त्रिकोणों का उपयोग करके नहीं बनाई गई है, तो हम इसे तोड़ने के लिए लाइब्रेरी [libtess](https://github.com/brendankenny/libtess.js/) का उपयोग करते हैं: [p5.RendererGL.Immediate.js](https://github.com/processing/p5.js/blob/main/src/webgl/p5.RendererGL.Immediate.js) में , हम `_processVertices()` के माध्यम से बहुभुज रूपरेखा चलाते हैं। लिबटेस द्वारा उन्हें त्रिकोणों में बदलने के बाद, वे एक ऐसे प्रारूप में होते हैं जहां एक शेडर उन्हें स्क्रीन पर खींच सकता है।


#### Strokes

उनके नाम के बावजूद, अलग-अलग चौड़ाई और शैलियों के स्ट्रोक का समर्थन करने के लिए स्ट्रोक को भी भरने की आवश्यकता होती है। किसी आकृति की रूपरेखा के साथ रेखाओं को क्षेत्रफल के साथ आकृतियाँ बनाने के लिए अपने केंद्र से विस्तारित होने की आवश्यकता होती है। स्ट्रोक का विस्तार तीन प्रकार की आकृतियाँ बनाता है: जोड़, कैप और खंड, जैसा नीचे दिखाया गया है।

<img alt="एक स्ट्रोक द्वारा बनाए गए खंड, जोड़ और टोपी के आकार का चित्रण।" src="images/line-diagram.svg" width="600" />
<!-- Generated via https://codepen.io/davepvm/pen/ZEVdppQ -->

जहां दो रेखा खंड जुड़ते हैं, वहां हम जोड़ जोड़ते हैं।

- एक मेटर जोड़ आयतों के किनारों को तब तक फैलाता है जब तक कि वे एक बिंदु पर प्रतिच्छेद न कर दें।
- एक बेवल जोड़ आयतों के कोनों को एक सीधी रेखा से जोड़ता है।
- एक गोल जोड़ कोनों को एक गोलाकार चाप से जोड़ता है। 

हम लाइन त्रिकोणों की पुनर्गणना किए बिना जॉइन शैलियों को बदलने का समर्थन करते हैं। ऐसा करने के लिए, हम प्रत्येक पंक्ति को दो त्रिभुजों से बने एक चतुर्भुज से जोड़ते हैं। क्वाड सीमा सभी संभावित सम्मिलित शैलियों को सीमित करती है। हम क्वाड के भीतर केवल उन पिक्सल को प्रदर्शित करने के लिए शेडर का उपयोग करते हैं जो चयनित जॉइन शैली में मौजूद हैं। हम बताते हैं कि प्रत्येक शैली नीचे दिए गए क्वाड में कैसे फिट बैठती है।

<img alt="एक स्ट्रोक जॉइन का बाउंडिंग क्वाड और प्रत्येक जॉइन शैली इसमें कैसे फिट होती है। बाउंडिंग क्वाड एक वर्ग है। मेटर जोड़ पूरे वर्ग को भर देते हैं। वर्ग के एक कोने से गोल जुड़ता है। बेवेल जोड़ वर्ग को एक सीधी रेखा में आधा काटते हैं।" src="images/joins.svg" width="600" />

हम लाइनों के कटे हुए सिरों पर मौजूद स्ट्रोक कैप के लिए एक समान रणनीति का उपयोग करते हैं। प्रत्येक टोपी एक चतुर्भुज है जो गोल, चौकोर और विस्तारित टोपी शैलियों को सीमित करती है। लाइन शेडर यह निर्धारित करता है कि उसे उन सीमाओं के भीतर कौन से पिक्सेल खींचने की आवश्यकता है। नीचे, हम बताते हैं कि प्रत्येक शैली क्वाड में कैसे फिट बैठती है।

<img alt="स्ट्रोक कैप का बाउंडिंग क्वाड और प्रत्येक शैली इसमें कैसे फिट होती है। बाउंडिंग क्वाड एक आयत है। विस्तारित टोपी पूरे आयत को भर देती है। गोल टोपी आयत के अंदर एक अर्धवृत्त रखती है। वर्गाकार टोपी आयत को खाली छोड़ देती है।" src="images/caps.svg" width="600" />

3डी आकृतियों में स्ट्रोक भी हो सकते हैं, लेकिन स्ट्रोक आकृतियों की गणना 2डी में की जाती है। इसका मतलब है कि वे कैमरे के परिप्रेक्ष्य के आधार पर बदल सकते हैं। हम यथासंभव पुनर्गणना से बचना चाहते हैं, इसलिए हम उस लाइन के बारे में सारी जानकारी संग्रहीत करते हैं जो कैमरे पर निर्भर नहीं है:

- हम **लाइन के केंद्र बिंदुओं** को मॉडल स्पेस में शामिल करते हैं, जो नीचे लाल रंग में दिखाया गया है।
- हम प्रत्येक आकृति के आरंभ और अंत में **रेखा की दिशा**, उसकी स्पर्शरेखा, क्रमशः नीले और गुलाबी रंग में दिखाते हैं। इससे हमें उन जोड़ों के आकार की गणना करने में मदद मिलती है जहां दो रेखाएं जुड़ती हैं।
- हम **एक ध्वज शामिल करते हैं जो आकृति के प्रत्येक कोने को विशिष्ट रूप से पहचानता है।** स्पर्शरेखा और सामान्य (स्पर्शरेखा का 90-डिग्री रोटेशन) के साथ संयुक्त, यह यह निर्धारित करने में मदद करता है कि रेखा को मोटाई देने के लिए किस दिशा में विस्तार करना है .

रेखा खींचने के लिए, हम स्क्रीन स्पेस में अंतिम रेखा स्थिति उत्पन्न करने के लिए उस जानकारी को एक शेडर में कैमरा इंट्रिनिक्स के साथ जोड़ते हैं।

<img alt="रेखाओं और उनके बनने वाले अंतिम आकारों के बारे में संग्रहीत जानकारी।" src="images/flags.svg" width="600" />


### आकार प्रतिपादन: तत्काल और बनाए रखा मोड

स्क्रीन पर आकृतियाँ बनाने के लिए p5.js दो मार्गों का उपयोग करता है: **तत्काल मोड** और **बरकरार मोड।**

**तत्काल मोड** उन आकृतियों के लिए अनुकूलित है जो हर फ्रेम को बदलती हैं। यदि आप एक ऐसा वक्र बना रहे हैं जो प्रत्येक फ्रेम को बदलता है, तो हर बार जब आप इसे बनाते हैं तो इसका आकार डेटा अलग होगा। इस वजह से, तत्काल मोड इसके लिए सबसे उपयुक्त है। यह p5.js को इंगित करता है कि इसे पुन: उपयोग के लिए आकृति को संग्रहीत करने में समय बर्बाद करने की आवश्यकता नहीं है, और यह ग्राफ़िक्स मेमोरी को समय के साथ सभी आकार विविधताओं से भरने से बचाता है। निम्नलिखित फ़ंक्शन इस मोड का उपयोग करते हैं:

- `vertex()`, `curveVertex()`, `bezierVertex()`, और `quadraticVertex()`, जिसे `beginShape()` और `endShape()` के बीच बुलाया जाता है
- `rect()` गोलाकार कोनों का उपयोग करते समय
- `bezier()`
- `curve()`
- `line()`
- `image()`

बनाए रखा गया मोड उन आकृतियों के लिए अनुकूलित है जिन्हें आपको दोबारा बनाते रहना होगा और आकार नहीं बदलना होगा। एक बार जब कोई आकृति त्रिभुजों से बन जाती है और उसे खींचने के लिए GPU पर भेज दी जाती है, तो रिटेन्ड मोड उसे वहीं रखता है। इसे फिर से त्रिकोणित करने या जीपीयू को दोबारा भेजे बिना समय बर्बाद किए बिना इसे फिर से खींचा जा सकता है। सहेजा गया आकार डेटा p5.Geometry ऑब्जेक्ट में रखा जाता है। p5.जियोमेट्री त्रिकोण डेटा संग्रहीत करता है और GPU पर इसके अपलोड किए गए बफ़र्स का ट्रैक रखता है। `freeGeometry()` को कॉल करने से स्थान बनाने के लिए GPU डेटा साफ़ हो जाता है। इसके बाद इसे दोबारा ड्रॉ करने पर डेटा दोबारा अपलोड हो जाएगा। p5.js में कई 3D आकार ड्राइंग फ़ंक्शन, जैसे `sphere()` या `cone()`, आंतरिक रूप से इसका उपयोग करते हैं।

आप तत्काल मोड कमांड से p5.Geometry बनाने के लिए buildGeometry() का उपयोग कर सकते हैं। आप इसे एक ऐसे फ़ंक्शन के साथ कॉल करते हैं जो किसी भी p5.js आकार ड्राइंग फ़ंक्शंस की एक श्रृंखला चलाता है। यह फ़ंक्शन चलाता है, आकृतियों को एक नए p5.Geometry में एकत्रित करता है, और उसे वापस कर देता है। फिर p5.ज्योमेट्री को भविष्य में कुशलतापूर्वक खींचा और पुनः तैयार किया जा सकता है।


## सामग्री, रोशनी और शेडर

हमारे द्वारा बनाई गई प्रत्येक आकृति को भरने के लिए एक ही शेडर का उपयोग किया जाता है, और उसके स्ट्रोक्स के लिए एक ही शेडर का उपयोग किया जाता है। कुछ डिफ़ॉल्ट शेडर्स हैं जिन्हें कोई भी p5.js में से चुन सकता है। आप डिफ़ॉल्ट शेडर के बजाय अपना स्वयं का शेडर भी लिख और उपयोग कर सकते हैं।

डिफ़ॉल्ट शेडर्स p5.js की प्रकाश व्यवस्था और सामग्री प्रणाली के साथ काम करते हैं। उपयोगकर्ता किसी आकार के साथ यह निर्दिष्ट कर सकता है कि दृश्य में कौन सी रोशनी हैं और प्रत्येक वस्तु रंग और चमक सहित प्रकाश पर कैसे प्रतिक्रिया करती है। यह जानकारी खींची गई प्रत्येक वस्तु के लिए शेडर को दी जाती है। कस्टम शेडर्स समान प्रकाश व्यवस्था और सामग्री जानकारी तक भी पहुंच सकते हैं, जिससे उपयोगकर्ताओं और लाइब्रेरी निर्माताओं को डिफ़ॉल्ट रेंडरिंग व्यवहार का विस्तार करने की अनुमति मिलती है।


### शेडर्स

P5 में कुछ शेडर्स निर्मित हैं:

- **रंग शेडर:** सपाट रंगों को चित्रित करने के लिए, `भरण()` या `स्ट्रोक()` का उपयोग करके सक्रिय किया जाता है।
- **लाइटिंग शेडर:** जटिल प्रकाश व्यवस्था और बनावट के साथ 2डी और 3डी आकार बनाने के लिए। `lights()`, `ambientLight()`, `directionalLight()`, `pointLight()`, और `spotLight()` को कॉल करके सक्रिय किया गया। प्रत्येक प्रकाश सूची में एक प्रकाश जोड़ता है। सभी अतिरिक्त रोशनी आकृति की छायांकन में योगदान करती हैं। यदि आप रोशनी का उपयोग नहीं करते हैं, तो रंग शेडर का उपयोग करके आकृति बनाई जाएगी, जो केवल भरण रंग का उपयोग करता है।
- **सामान्य/डीबग शेडर:** सामान्य सतह को रंग के रूप में उपयोग करके 2डी और 3डी आकार बनाने के लिए। इसे `normalMaterial()` कहकर सक्रिय किया जाता है।


### रोशनी

उपयोगकर्ता `ambientLight()`, `directionalLight()`, `pointLight()`, और `spotLight()` सेट कर सकते हैं। प्रत्येक प्रकाश सूची में एक प्रकाश जोड़ता है। सभी अतिरिक्त रोशनी आकृति की छायांकन में योगदान करती हैं। उन सभी का एक रंग होता है, और कुछ के कुछ अन्य पैरामीटर होते हैं, जैसे स्थिति या दिशा।

`एम्बिएंटलाइट()` को छोड़कर सभी के लिए, जोड़ा गया प्रत्येक प्रकाश आकृतियों के दृश्य-स्वतंत्र प्रकाश और दृश्य-निर्भर प्रतिबिंबों में योगदान देता है। प्रत्येक प्रकाश का प्रतिबिंब, डिफ़ॉल्ट रूप से, उस प्रकाश के रंग से मेल खाता है। यदि वांछित है, तो कोई `specularColor()` सेट करके सभी प्रतिबिंबों का रंग बदल सकता है।

यदि आप रोशनी का उपयोग नहीं करते हैं, तो आकृति **रंग शेडर** का उपयोग करके बनाई जाएगी, जो केवल भरण रंग का उपयोग करता है।


### सामग्री

प्रत्येक 3डी ऑब्जेक्ट में कुछ भौतिक गुण होते हैं जिन्हें उपयोगकर्ता द्वारा निर्धारित किया जा सकता है:

- **रंग भरें:** यह वह रंग है जो आप तब देखते हैं जब रोशनी नहीं होती है। इसे `भरें()` के साथ सेट करें। यदि आकृति बनाने से पहले किया जाए तो यह पूरी आकृति पर लागू होता है। यदि `beginShape()`/`endShape()` के बीच `vertex()` से पहले कॉल किया जाता है, तो यह केवल उस शीर्ष पर लागू होगा। एक बनावट, यदि `बनावट()` पर कॉल से मौजूद है, तो भरण को ओवरराइड कर देगी। जब रोशनी होगी, तो यह रंग प्रकाश के फैले हुए घटक के साथ मिश्रित हो जाएगा। फैला हुआ घटक सतह पर सीधे प्रकाश पड़ने के कारण सतह के उज्ज्वल और अंधेरे क्षेत्रों का वर्णन करता है।
- **स्पेक्युलर सामग्री:** यह वह रंग है जो प्रकाश के स्पेक्युलर घटक के साथ मिश्रित हो जाता है। स्पेक्युलर घटक आकृति की सतह पर दिखाई देने वाले प्रतिबिंबित हाइलाइट्स का वर्णन करता है। इस पैरामीटर को `specularMaterial()` के साथ सेट करें। यदि अनिर्दिष्ट है, तो आकृति में कोई प्रतिबिंब नहीं होगा।
- **चमकदारता:** `चमकदार()` के साथ सेट करें, यह स्पेक्युलर प्रतिबिंब कितने तेज हैं।
- **परिवेश सामग्री:** यह वह रंग है जो परिवेशीय प्रकाश के साथ मिश्रित हो जाता है। परिवेशीय प्रकाश आकृति पर निरंतर सर्वदिशात्मक प्रकाश का वर्णन करता है। इस पैरामीटर को `ambientMaterial()` के साथ सेट करें। यदि अनिर्दिष्ट है, तो यह भरण रंग के समान होगा।
- **उत्सर्जक सामग्री**: `उत्सर्जक सामग्री()` के साथ सेट करें, यह आकृति की रोशनी में एक स्थिर रंग जोड़ता है, जैसे कि वह उस रंग की अपनी रोशनी पैदा कर रहा हो।


### शेडर कार्यान्वयन

प्रकाश व्यवस्था और सामग्री पैरामीटर शेडर विशेषताओं और वर्दी में बदल जाते हैं। यदि आप उन्हें कस्टम शेडर में संदर्भित करते हैं, तो p5.js उन्हें स्वचालित रूप से आपूर्ति करेगा।

जबकि उन्नत शेडर लेखक इन गुणों का लाभ उठा सकते हैं, नए उपयोगकर्ताओं के लिए यह अस्पष्ट हो सकता है। भविष्य के लक्ष्य अनुभाग में, हम एपीआई में सुधार के लिए कुछ योजनाओं का वर्णन करते हैं। हम सार्वजनिक रूप से इसका दस्तावेजीकरण करने और इसका समर्थन करने से पहले इसमें सुधार करना चाह सकते हैं।


#### वैश्विक

सभी संदर्भों में सभी वस्तुओं के लिए, निम्नलिखित वैश्विक वर्दी उपलब्ध हैं:

- `यूनिफ़ॉर्म mat4 uModelViewMatrix`: ऑब्जेक्ट-स्पेस स्थिति को कैमरा-स्पेस में बदलने के लिए एक मैट्रिक्स
- `यूनिफ़ॉर्म mat4 uProjectionMatrix`: कैमरा-स्पेस स्थिति को स्क्रीन स्पेस में बदलने के लिए एक मैट्रिक्स
- `यूनिफ़ॉर्म mat3 uNormalMatrix`: ऑब्जेक्ट-स्पेस मानदंडों को कैमरा-स्पेस में परिवर्तित करने के लिए एक मैट्रिक्स

इसके अतिरिक्त, ये प्रति-शीर्ष गुण विशेषताओं के रूप में उपलब्ध हैं:

- `विशेषता vec3 aPosition`: वस्तु स्थान में शीर्ष की स्थिति
- `विशेषता vec3 aNormal`: भरण के लिए, सतह से बाहर की ओर इंगित करने वाली दिशा
- `विशेषता vec2 aTexCoord`: भरण के लिए, बनावट छवि पर किसी स्थान को संदर्भित करते हुए x और y में 0 और 1 के बीच एक समन्वय
- `विशेषता vec3 aVertexColor`: भरने के लिए, एक वैकल्पिक प्रति-वर्टेक्स रंग


#### रोशनी

- `यूनिफ़ॉर्म बूल यूयूज़लाइटिंग`: रोशनी प्रदान की गई है या नहीं

यदि `uUseLighting` सेट किया गया है, तो आगे की प्रकाश व्यवस्था की जानकारी इसमें दी जाएगी:


##### परिवेशीय रोशनी

- `यूनिफ़ॉर्म int uAmbientLightCount`: कितनी परिवेशी लाइटें मौजूद हैं, अधिकतम 5 तक
- `यूनिफ़ॉर्म vec3 uAmbientColor[5]`: परिवेशीय हल्के रंग


##### दिशात्मक रोशनी

- `यूनिफ़ॉर्म int uDirectionalLightCount`: कितनी दिशात्मक रोशनी मौजूद हैं, अधिकतम 5 तक
- `यूनिफ़ॉर्म vec3 uLightingDirection[5]`: प्रकाश दिशाएँ
- `यूनिफ़ॉर्म vec3 uDirectionalDiffuseColors[5]`: हल्के फैले हुए रंग
- `यूनिफ़ॉर्म vec3 uडायरेक्शनल स्पेक्युलर कलर्स[5]`: हल्के स्पेक्युलर रंग


##### प्वाइंट लाइटें

- `यूनिफ़ॉर्म int uPointLightCount`: अधिकतम 5 तक, कितनी पॉइंट लाइटें मौजूद हैं
- `यूनिफ़ॉर्म vec3 uPointLightLocation[5]`: बिंदु रोशनी का स्थान
- `यूनिफ़ॉर्म vec3 uPointLightDiffuseColors[5]`: बिंदु रोशनी के बिखरे हुए रंग
- `यूनिफ़ॉर्म vec3 uPointLightSpeculularColors[5]`: पॉइंट लाइट के स्पेक्युलर रंग

##### स्पॉट लाइटें

- `यूनिफ़ॉर्म इंट यूस्पॉटलाइटकाउंट`: कितनी स्पॉट लाइटें मौजूद हैं, अधिकतम 5 तक
- `यूनिफ़ॉर्म फ़्लोट uSpotLightAngle[5]`: स्पॉट लाइट शंकु त्रिज्या
- `यूनिफ़ॉर्म फ़्लोट uSpotLightConc[5]`: प्रत्येक स्पॉट लाइट की एकाग्रता (फ़ोकस)
- `यूनिफ़ॉर्म vec3 uSpotLightDiffuseColors[5]`: हल्के फैले हुए रंग
- `यूनिफ़ॉर्म vec3 uSpotLightSpeculularColors[5]`: हल्के स्पेक्युलर रंग
- `यूनिफ़ॉर्म vec3 uSpotLightLocation[5]`: स्पॉट लाइट स्थान
- `यूनिफ़ॉर्म vec3 uSpotLightDirection[5]`: स्पॉट लाइट दिशाएँ


#### सामग्री

##### रंग भरना

- `यूनिफ़ॉर्म vec4 uMaterialColor`: आकार भरें रंग
- `यूनिफ़ॉर्म बूल uUseVertexColor`: क्या प्रति-वर्टेक्स रंग हैं जो आकार भरने वाले रंग को ओवरराइड करते हैं
- `विशेषता vec4 aVertexColor`: प्रति-वर्टेक्स भरण रंग
- `यूनिफ़ॉर्म बूल इज़टेक्सचर`: क्या कोई बनावट निर्दिष्ट है
- `यूनिफ़ॉर्म सैम्पलर2डी यूसैम्पलर`: एक बनावट
- `यूनिफ़ॉर्म vec4 uTint`: बनावट के लिए एक टिंट गुणक


##### स्पेक्युलर प्रतिबिंब

- `यूनिफ़ॉर्म बूल यूस्पेक्युलर`: क्या प्रतिबिंब दिखाना है
- `यूनिफ़ॉर्म फ़्लोट यू शाइनीनेस`: सामग्री की चमक
- `यूनिफ़ॉर्म vec4 uSpeularMatColor`: स्पेक्युलर प्रकाश के साथ मिश्रण करने के लिए सामग्री का रंग


##### परिवेश रंग

- `यूनिफ़ॉर्म बूल uHasSetAmbient`: क्या परिवेश रंग सेट किया गया है या क्या इसे डिफ़ॉल्ट रूप से भरण रंग में सेट किया जाना चाहिए
- `यूनिफ़ॉर्म vec4 uAmbientMatColor`: परिवेश प्रकाश के साथ मिश्रण करने के लिए सामग्री का रंग


#### अन्य शेडर इनपुट

##### पंक्तियाँ

डिफ़ॉल्ट लाइन शेडर स्वचालित रूप से वर्दी में इन वैश्विक गुणों के साथ आपूर्ति की जाती है:

- `uniform vec4 uViewport`: एक वेक्टर जिसमें स्क्रीन आयत का `[minX, minY, maxX, maxY]` होता है
- `uniform इंट यूपर्सपेक्टिव`: एक बूलियन निर्दिष्ट करता है कि लाइन मोटाई पर परिप्रेक्ष्य प्रक्षेपण लागू करना है या नहीं
- `uniform इंट यूस्ट्रोकजॉइन`: जॉइन शैली का प्रतिनिधित्व करने वाला एक एनम। 0, 1, और 2 `ROUND`, `MITER`, `BEVEL` का प्रतिनिधित्व करते हैं।
- `uniform int uStrokeCap`: कैप शैली का प्रतिनिधित्व करने वाला एक एनम। 0, 1, और 2 'गोल', 'प्रोजेक्ट', 'वर्ग' का प्रतिनिधित्व करते हैं।

इसमें निम्नलिखित प्रति-शीर्ष विशेषताएँ भी हैं:

- `uniform vec3 aTangentIn`: रेखा खंड की शुरुआत में 3डी दिशा
- `uniform vec3 aTangentOut`: रेखा खंड के अंत में 3D दिशा
- `attribute float aside`: एक एनम यह दर्शाता है कि स्ट्रोक के किस भाग पर बिंदु स्थित है। विवरण के लिए स्ट्रोक्स अनुभाग देखें।

##### अंक

- `uniform float uPointSize`: खींचे जा रहे बिंदु की त्रिज्या

## कक्षाएं

अधिकांश WebGL कोड का प्रवेश बिंदु **p5.RendererGL** के माध्यम से होता है। शीर्ष-स्तरीय p5.js फ़ंक्शंस वर्तमान रेंडरर को पास कर दिए जाते हैं। 2डी और वेबजीएल दोनों मोड में रेंडरर क्लास हैं जो इस सामान्य इंटरफ़ेस के अनुरूप हैं। तत्काल मोड और बनाए रखा मोड फ़ंक्शन **p5.RendererGL.Immediate.js** और **p5.RendererGL.Retained.js** में विभाजित हैं।

रेंडरर के भीतर, मॉडलों के संदर्भ **retainedMode.geometry** मानचित्र में संग्रहीत होते हैं। प्रत्येक मान **p5.Geometry** के बफ़र्स को संग्रहीत करने वाला एक ऑब्जेक्ट है। पहली बार मॉडल (योर ज्योमेट्री) को कॉल करते समय, रेंडरर मानचित्र में एक प्रविष्टि जोड़ता है। इसके बाद यह ज्यामिति के GPU संसाधनों के संदर्भ संग्रहीत करता है। यदि आप एक p5.Geometry को मुख्य कैनवास और एक WebGL p5.Graphics पर भी बनाते हैं, तो इसमें दो रेंडरर्स में प्रविष्टियाँ होंगी।

प्रत्येक सामग्री को **p5.Shader द्वारा दर्शाया जाता है।** आप शेडर (आपका शेडर) फ़ंक्शन के माध्यम से रेंडरर में वर्तमान शेडर सेट करते हैं। यह क्लास शेडर सोर्स कोड संकलित करने और शेडर यूनिफॉर्म सेट करने का काम संभालती है।

शेडर यूनिफ़ॉर्म सेट करते समय, यदि यूनिफ़ॉर्म प्रकार एक छवि है, तो रेंडरर इसके लिए एक p5.Texture बनाता है। प्रत्येक p5.Image, p5.Graphics, p5.MediaElement, या p5.Framebuffer एसेट को एक मिलेगा। यह GPU पर छवि डेटा के प्रतिनिधित्व का ट्रैक रखता है। शेडर में एसेट का उपयोग करने से पहले, यदि आवश्यक हो तो p5.js GPU को नया डेटा भेजेगा। छवियों के लिए, ऐसा तब होता है जब किसी उपयोगकर्ता ने किसी छवि के पिक्सेल को मैन्युअल रूप से अपडेट किया हो। ऐसा डेटा वाली परिसंपत्तियों के लिए हर फ्रेम में होता है, जो प्रत्येक फ्रेम में बदल सकता है, जैसे कि वीडियो या पी5.ग्राफिक्स।

**p5.Framebuffer** ऑब्जेक्ट से संबंधित बनावट अद्वितीय हैं। फ़्रेमबफ़र ग्राफ़िक्स की तरह होते हैं: वे उन सतहों का प्रतिनिधित्व करते हैं जिन पर खींचा जा सकता है। P5.ग्राफिक्स के विपरीत, फ़्रेमबफ़र्स पूरी तरह से GPU पर रहते हैं। यदि कोई शेडर में बनावट के रूप में p5.ग्राफिक्स का उपयोग करता है, तो डेटा को सीपीयू से स्थानांतरित करने की आवश्यकता होती है। यह अक्सर एक प्रदर्शन बाधा हो सकती है। इसके विपरीत, फ़्रेमबफ़र पर ड्राइंग करते समय, आप सीधे इसकी GPU बनावट पर आकर्षित होते हैं। इस वजह से, कोई अतिरिक्त डेटा स्थानांतरण आवश्यक नहीं है। WebGL मोड इस कारण से जहां संभव हो वहां p5.ग्राफिक्स पर p5.Framebuffers का उपयोग करने का प्रयास करता है।


## भविष्य के लक्ष्य

वर्तमान में, WebGL मोड विभिन्न कार्यों के लिए कार्यात्मक है, लेकिन कई उपयोगकर्ता और पुस्तकालय निर्माता इसे नई दिशाओं में विस्तारित करना चाहते हैं। हमारा लक्ष्य उपयोगकर्ताओं और पुस्तकालय निर्माताओं के लिए बिल्डिंग ब्लॉक्स का एक सेट बनाना है जिससे वे एक्सटेंशन तैयार कर सकें। एक ब्लॉक को "पूर्ण" माना जा सकता है जब इसमें एक एक्स्टेंसिबल एपीआई हो जिसे हम आत्मविश्वास से समर्थन करने के लिए प्रतिबद्ध कर सकें। वेबजीएल मोड के लिए एक प्रमुख मील का पत्थर तब होगा जब हमारे पास पुस्तकालयों के पारिस्थितिकी तंत्र के लिए ऐसे ब्लॉकों का पर्याप्त सेट होगा। वर्तमान में विस्तार समर्थन की कमी वाले मुख्य क्षेत्र ज्यामिति और सामग्री हैं।

- **समृद्ध सामग्री का समर्थन करने के लिए p5.Geometry का विस्तार करें।** कोई ज्यामिति बना सकता है, लेकिन कई कार्य जिन्हें उपयोगकर्ता पूरा करना चाहता है, वे अभी तक स्थिर एपीआई के साथ समर्थित नहीं हैं। कोई व्यक्ति ज्यामिति को कुशलतापूर्वक अद्यतन करना चाह सकता है, जो एनिमेटेड gltf मॉडल का समर्थन करने के लिए आवश्यक है। कोई व्यक्ति एकाधिक सामग्रियों को एक वस्तु में समूहित करना चाह सकता है, यदि वे किसी आयातित मॉडल में मौजूद हों। कोई शेडर के साथ काम करने के लिए कस्टम वर्टेक्स विशेषताएँ जोड़ना चाह सकता है। ये कार्य वर्तमान में असमर्थित हैं.
- **कम भंगुर कस्टम शेडर्स सक्षम करें।** एक ऐसा शेडर बनाने के लिए जो p5.js की प्रकाश व्यवस्था और सामग्री प्रणाली को एकीकृत करता है, उपयोगकर्ता को वर्तमान में स्क्रैच से शेडर बनाने के लिए मजबूर किया जाता है। ये शेडर्स अक्सर डिफ़ॉल्ट शेडर्स के हिस्सों को कॉपी और पेस्ट करते हैं। यदि आंतरिक नामकरण या संरचना में परिवर्तन होता है तो यह संस्करणों के बीच टूट सकता है। कम भंगुर होने के लिए, पुस्तकालयों को डिफ़ॉल्ट टुकड़ों को आयात और पुन: उपयोग करने में सक्षम होना चाहिए। यह पुस्तकालयों को पोजिशनिंग लॉजिक का पुन: उपयोग करने या पोजिशनिंग लॉजिक को बढ़ाने की सुविधा देता है, लेकिन शेडिंग लॉजिक का पुन: उपयोग करने देता है। वर्तमान में [इस कार्य के लिए एक मुद्दा खुला है।](https://github.com/processing/p5.js/issues/6144)
- **प्रदर्शन में सुधार।** WebGL मोड सुविधाओं और प्रदर्शन के बीच संतुलन बनाने का प्रयास करता है। एक तरीका आउटपुट गुणवत्ता को ट्यून करने के लिए एपीआई पेश करना है, जैसे कि कैसे `कर्वडिटेल ()` तेज़ लेकिन निम्न-गुणवत्ता वाले कर्व्स की अनुमति देता है। लाइन रेंडरिंग अपनी वर्तमान स्थिति में सामान्य प्रदर्शन बाधाओं में से एक है, और इसमें कम निष्ठा लेकिन उच्च प्रदर्शन विकल्प होने से लाभ हो सकता है। एक अन्य विधि नए प्रकार के ऑब्जेक्ट और रेंडरिंग विधियों को पेश करना है जो विभिन्न उपयोग पैटर्न के लिए अनुकूलित हैं, जैसे कि कैसे `एंडशेप (चाहिए बंद करें, गिनती करें)` अब कई आकृतियों के अधिक कुशल ड्राइंग के लिए वेबजीएल 2 इंस्टेंस्ड रेंडरिंग का समर्थन करता है।

