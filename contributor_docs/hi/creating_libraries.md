# लाइब्रेरी बनाना

p5.js लाइब्रेरी कोड हो सकती है जो p5.js कोर फ़ंक्शनैलिटी को बढ़ाने या जोड़ने के लिए जावास्क्रिप्ट को विस्तारित करती है। इसमें दो प्रकार की लाइब्रेरी होती हैं। कोर लाइब्रेरीज (p5.Sound) p5.js डिस्ट्रीब्यूशन का हिस्सा होती हैं, जबकि योगदानीय लाइब्रेरीज सदस्यों के द्वारा विकसित, स्वामित्व, और रखी जाती हैं जो p5.js समुदाय के सदस्य होते हैं।

यदि आपने एक लाइब्रेरी बनाई है और आप चाहते हैं कि इसे [p5js.org/libraries](https://p5js.org/libraries) पृष्ठ पर शामिल किया जाए, तो [इस फॉर्म](https://docs.google.com/forms/d/e/1FAIpQLSdWWb95cfvosaIFI7msA7XC5zOEVsNruaA5klN1jH95ESJVcw/viewform). को सबमिट करें।

# एक नई लाइब्रेरी बनाएं

यहां आपको जावास्क्रिप्ट लेखन और p5.js के साथ इस्तेमाल करने के कई तरीके मिलते हैं। यहां आपकी लाइब्रेरी को अच्छी तरह से काम करने के लिए कुछ नोट्स हैं।

## कोड

### आप p5.prototype में विधियों को जोड़कर p5 कोर फ़ंक्शनैलिटी को बढ़ा सकते हैं।

उदाहरण के लिए, नीचे दिए गए कोड में dom.js में `createImg()` जोड़ा गया है जो DOM में [HTMLImageElement](https://developer.Mozilla.org/en-US/docs/Web/API/HTMLImageElement) जोड़ता है।


  ```js
  p5.prototype.createImg = function (src) {
    const elt = document.createElement('img');
    //const elt = new Image; // इसमें से एक को वृद्धि के लिए बहुत संक्षेपित विकल्प।

    elt.src = src;
    return addElement(elt, this);
  };
  ```
 जब DOM लाइब्रेरी परियोजना में शामिल की जाती है, तो `createImg()` को `createCanvas()` या `background()` की तरह कॉल किया जा सकता है।

### आंतरिक सहायकों के लिए आंतरिक फ़ंक्शन्स का उपयोग करें।

उपयोगकर्ताओं द्वारा कॉल किए जाने की नहीं होने वाले फ़ंक्शन्स। उपरोक्त उदाहरण में `addElement()` [dom.js](https://GitHub.com/processing/p5.js/blob/main/src/dom/dom.js) में एक आंतरिक फ़ंक्शन है। इसे p5.prototype के साथ सार्वजनिक रूप से बांधा नहीं जाता है।

### आप p5.js class को भी विस्तारित कर सकते हैं, उनके prototypes में विधियों को जोड़कर।

नीचे दिए गए उदाहरण में, `p5.Element.prototype` को `html()` विधि के साथ विस्तारित किया गया है, जो तत्व के आंतरिक एचटीएमएल को सेट करता है।


  ```js
  p5.Element.prototype.html = function (html) {
    this.elt.innerHTML = html;
    //this.elt.textContent = html; // innerHTML के लिए बहुत सुरक्षित विकल्प।
  };
  ```

### registerPreloadMethod() का उपयोग करें ताकि प्रीलोड() में कहा जा सके कि कौन-कौन से विधियों को कॉल किया जा सकता हैं।

सामान्यत: कुछ एसिंक्रोनस फ़ंक्शन्स के साथ (जैसे कि ध्वनि, छवि, या अन्य बाह्य फ़ाइल लोड करना) में, एक विकल्पक स्थिति और एसिंक्रोनस विकल्प दोनों प्रदान किए जाते हैं। उदाहरण के लिए, `loadStrings(path, [callback])` एक वैकल्पिक दूसरे कॉलबैक आर्ग्यमेंट को स्वीकार करता है - एक फ़ंक्शन जो लोडStrings फ़ंक्शन पूर्ण होने के बाद कॉल होता है। हालांकि, एक उपयोगकर्ता इसे `preload()` में बिना कॉलबैक के भी कॉल कर सकता है, और p5.js `preload() `पूर्ण होने का इंतज़ार करेगा जब तक कि `setup()` में आगे नहीं बढ़ता है। यदि आप अपनी विधि को प्रीलोड() में बिना कॉलबैक के बुलाना चाहते हैं, तो आप `registerPreloadMethod()` के साथ अपनी विधि का नाम पंजीकृत कर सकते हैं, और इसे ~~(पूर्वनिर्धारित रूप से p5.prototype)~~ से गुजारने वाले प्रोटोटाइप ऑब्जेक्ट के साथ पास करें। नीचे के उदाहरण में "soundfile.js" (p5.sound लाइब्रेरी) में `loadSound()` को पंजीकृत करने की एक पंक्ति है।


  ```js
  p5.prototype.registerPreloadMethod('loadSound', p5.prototype);
  ```

### आंतरिक कॉलबैक और preload() के लिए एसिंक फ़ंक्शन का उदाहरण।

```js
// preload() या कॉलबैक के साथ एसिंक फ़ंक्शन का उदाहारण।
p5.prototype.getData = function (callback) {
  /// एक ऑब्जेक्ट बनाएं जो एसिंक फ़ंक्शन से डेटा को क्लोन करेगा और इसे लौटाएगा।
  // हमें उस ऑब्जेक्ट को नीचे अपडेट करने की आवश्यकता है, उसे पुनर-निर्धारित करने/पुनर-असाइन करने की नहीं।
  // यह preload() के लिए महत्वपूर्ण है क्योंकि असली पॉइंटर/रेफरेंस को सहेजने के लिए।
  // Const के साथ चर नाम घोषित करने से यह सुनिश्चित होता है कि उन्हें भूल से पुनर-निर्धारित नहीं किया जाएगा।
  const ret = {};
  // आपके साथ काम कर रहे कुछ एसिंक फ़ंक्शन।
  loadDataFromSpace(function (data) {
    // डेटा में गुणों में फ़ॉरच करें।
    for (let prop in data) {
      // Set the ret's properties to be the data's properties (cloning).
      // That is, update empty ret object with properties from received data.
      // You CANNOT overwrite/reassign ret with another object though.
      // Rather its content needs to be updated with the data.
      ret[prop] = data[prop];
    }
    // Check whether callback is indeed a function.
    if (typeof callback == 'function') {
      callback(data); // do the callback.
    }
  });
  // Return the object which has been filled with the data above.
  return ret;
};
```

### registerMethod() और unregisterMethod() का उपयोग करके फ़ंक्शनों को p5 के साथ रजिस्टर और अनरजिस्टर करने के लिए।

  ```js
  p5.prototype.doRemoveStuff = function () { 
  // लाइब्रेरी सफाई साफ-सफाई
  };
  p5.prototype.registerMethod('remove', p5.prototype.doRemoveStuff);
  // जब यह और आवश्यक नहीं हो, तो फिर मैथड को अनरजिस्टर करें।
  p5.prototype.unregisterMethod('remove', p5.prototype.doRemoveStuff);
  ```

रजिस्टर और अनरजिस्टर करने के लिए आपके पास निम्नलिखित सूची के साथ फ़ंक्शन नाम हैं। ध्यान दें कि आपको फ़ंक्शन को पहले परिभाषित करना हो सकता है:

  * **pre** — `draw()` के शुरुआत में कॉल किया जाता है। यह  चित्रण पर प्रभाव डाल सकता है।
  * **post** — `draw()` के अंत में कॉल किया जाता है।
  * **remove** — `remove()` को कॉल करने पर कॉल किया जाता है।
  * **init** — स्केच को पहली बार शुरू करते समय कॉल किया जाता है, स्केच प्रारंभीकरण फ़ंक्शन (जो `p5` कंस्ट्रक्टर में पारित किया गया था) के निष्पादन से पहले। यह भी किसी भी वैश्विक मोड सेटअप से पहले कॉल किया जाता है, ताकि आपकी लाइब्रेरी स्केच में कुछ भी जोड़ सके और यदि वैश्विक मोड सक्रिय है तो यह स्वचालित रूप से `विंडो` में कॉपी हो जाए।
  * **beforePreload** — `preload()` फ़ंक्शन के पहले कॉल किया जाता है।
  * **afterPreload** — `preload()` फ़ंक्शन के बाद कॉल किया जाता है।
  * **beforeSetup** — `setup()` फ़ंक्शन के पहले कॉल किया जाता है।
  * **afterSetup** — `setup()` फ़ंक्शन के बाद कॉल किया जाता है।

जल्द ही इस सूची के साथ और भी आएगा: https://GitHub.com/processing/processing/wiki/Library-Basics#library-methods


### आप अपनी खुद की classes भी बना सकते हैं।

आपकी लाइब्रेरी संभाल सकती है कि वह पूरी तरह से p5 या p5 classes को नहीं बढ़ाती है, बल्कि केवल उपयोगकर्ताओं को उससे संबंधित classes प्रदान करती है। या यह दोनों का मिश्रण कर सकती है।

## नामकरण

* **p5 फ़ंक्शन या गुण अधिरोहित न करें।** जब आप p5.prototype को विस्तारित कर रहे होते हैं, ध्यान दें कि आप मौजूदा गुणों या फ़ंक्शनों के नामों का उपयोग नहीं कर रहे हैं। आप [hasOwnProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty) का उपयोग नामों की जांच के लिए कर सकते हैं। उदाहारण के लिए, निम्नलिखित लाइन आपके लाइब्रेरी फ़ाइल के शीर्ष में रखने पर सत्य प्रिंट करेगी क्योंकि `rect()` विधि मौजूद है:


  ```js
  console.log(p5.prototype.hasOwnProperty('rect'));
  ```

* **उसी तरह, p5 कक्षा के फ़ंक्शन या गुणों को अधिरोपित न करें।** यदि आप p5.Image, p5.Vector, p5.Element आदि को विस्तारित कर रहे हैं, तो उपर दिए गए प्रोटोकॉल का पालन करें।

* **p5.js के दो मोड होते हैं, ग्लोबल मोड और इंस्टेंस मोड।** ग्लोबल मोड में, सभी p5 गुण और विधियां विंडो ऑब्जेक्ट से जुड़ी होती हैं, जिससे उपयोगकर्ता को `background()` जैसी विधियों को किसी भी चीज़ के साथ प्रिफ़िक्स किए बिना बुलाने का सुविधानुसार कार्य कर सकता है। हालांकि, इसका मतलब है कि आपको सावधान रहना चाहिए कि आप प्राकृतिक JavaScript कार्यक्षमता को अधिरोपित नहीं कर रहे हैं। आप इसे कन्सोल में लिखकर या एक तेज़ गूगल सर्च के साथ मौजूद JS नामों का परीक्षण कर सकते हैं।

* **कक्षाएँ सामान्यत: मेज़केस, और विधियाँ छोटे अक्षरों से शुरू होती हैं।** p5 में कक्षाएँ p5 के साथ प्रारंभ होती हैं। हम चाहेंगे कि इस नामकक्ष को केवल p5 कोर कक्षाओं के लिए ही बनाए रखें, इसलिए जब आप अपने खुद के बना रहे हैं, **कृपया कक्षा नामों के लिए p5. प्रीफ़िक्स शामिल न करें।** आप अपना खुद का प्रीफ़िक्स बना सकते हैं, या उन्हें बिना प्रीफ़िक्स के नाम दे सकते हैं।

* **p5.js लाइब्रेरी फ़ाइलों का नाम भी p5 के साथ प्रीफ़िक्स के साथ है**, कक्षाओं से उन्हें भिन्न करने के लिए। उदाहरण के लिए, p5.sound.js। आपको अपनी फ़ाइलों के नाम को इसी प्रारूप का पालन करने के लिए प्रेरित किया जाता है।


## पैकेजिंग

* **एकल JS फ़ाइल बनाएं जिसमें आपकी पुस्तकालय हो।** इससे उपयोगकर्ताओं को इसे अपने परियोजनाओं में लिंक करना आसान होता है। आप एक सामान्य JS फ़ाइल और तेज लोडिंग के लिए [ मिनीफाइड ](http://jscompress.com/)संस्करण के लिएविकल्पों की भी सोच सकते हैं।

* **योगदानित पुस्तकालयें उनके निर्माताओं द्वारा होस्ट की जाती हैं, उनके द्वारा दस्तावेजित की जाती हैं, और उनका रखरखाव किया जाता है।** यह GitHub पर, एक अलग वेबसाइट पर, या कहीं और हो सकता है।

* **दस्तावेज़ीकरण महत्वपूर्ण है!** आपकी पुस्तकालय के लिए दस्तावेज़ सुबिधाजनक स्थान पर होना चाहिए ताकि उपयोगकर्ता जो पुस्तकालय डाउनलोड और उपयोग करते हैं, उन्हें आसानी से मिल सके। योगदानित पुस्तकालयों के लिए मुख्य p5.js संदर्भ में उनका वर्णन शामिल नहीं होगा, लेकिन आपको एक ही स्वरूप का पालन करना चाहिए। [यहां](http://p5js.org/reference/#/libraries/p5.sound) library का अवलोकन पृष्ठ, [ वर्ग का अवलोकन पृष्ठ](http://p5js.org/reference/#/p5.Vector), और [ विधि पृष्ठ](http://p5js.org/reference/#/p5/arc) के उदाहरण देखें।

* **उदाहरण भी बढ़िया होते हैं!** वे लोगों को दिखाते हैं कि आपकी पुस्तकालय क्या कर सकती है। क्योंकि यह सब जावास्क्रिप्ट है, लोग उन्हें ऑनलाइन डाउनलोड करने से पहले ऑनलाइन देख सकते हैं। [jsfiddle](http://jsfiddle.net/) और [codepen](http://codepen.io) उदाहरण होस्ट करने के लिए दो शानदार विकल्प हैं।

* **हमें बताएं!** जब आपकी libraries वितरण के लिए तैयार हो जाए, [hello@p5js.org](mailto:hello@p5js.org) पर एक लिंक और कुछ जानकारी भेजें। हम इसे [libraries पृष्ठ](http://p5js.org/libraries/) में शामिल करेंगे!